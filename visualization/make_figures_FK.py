import os
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import matplotlib.cm as cm
import numpy as np
import navis
from pathlib import Path
import pandas as pd
import matplotlib as mpl
from scipy.stats import gaussian_kde
from hindbrain_structure_function.visualization.FK_tools.load_pa_table import *
from hindbrain_structure_function.visualization.FK_tools.load_clem_table import *
from hindbrain_structure_function.visualization.FK_tools.load_mesh import *
from hindbrain_structure_function.visualization.FK_tools.load_brs import *
from hindbrain_structure_function.visualization.FK_tools.get_base_path import *
from hindbrain_structure_function.visualization.FK_tools.load_em_table import *
from hindbrain_structure_function.visualization.FK_tools.load_synapse import *
from datetime import datetime
import plotly
import matplotlib
import warnings
from matplotlib.lines import Line2D
warnings.filterwarnings("ignore")

# matplotlib.use('qt5agg')
class make_figures_FK:
    """
    A class for generating and saving various visualizations of brain cells based on neurotransmitter types, spatial projections, and interactive 3D models.

    This class provides functionalities to create visual representations of brain cells, categorizing them based on their neurotransmitter types (inhibitory, excitatory, or unspecified). It also allows for the generation of 2D spatial projections (Y and Z axes) and interactive 3D plots of the cells, with options to include selected brain regions for enhanced context.

    Upon initialization, the class loads and processes cell data from specified modalities (e.g., 'pa' for photoactivation, 'clem' for correlative light and electron microscopy) and keywords (e.g., 'integrator', 'contralateral') to filter the cells of interest. It then loads the mesh data for each cell that fits the queries in the selected modalities.

    The visualizations generated by this class can include selected brain regions, differentiated cell types by color, and can be saved in various formats including HTML (for interactive 3D plots), PDF, PNG, and SVG.

    Parameters:
    - modalities (list of str): The imaging modalities to load cell data from. Currently supports 'pa' and 'clem'. Default is ['pa'].
    - keywords (list of str): Keywords to filter the cells by their type labels. Default is ['integrator', 'contralateral'].

    Attributes:
    - name_time (datetime): Timestamp used for naming saved files to ensure uniqueness.
    - path_to_data (Path): The path to the directory containing cell and mesh data.
    - all_cells (DataFrame): The loaded and processed DataFrame containing cell data after filtering by modalities and keywords.

    Methods:
    - plot_z_projection(show_brs=False, force_new_cell_list=False, ylim=[-700, -200]): Generates and saves a 2D Z-axis projection plot.
    - plot_y_projection(show_brs=False, force_new_cell_list=False): Generates and saves a 2D Y-axis projection plot.
    - make_interactive(show_brs=True): Generates and saves an interactive 3D plot of visualized brain cells.
    - plot_neurotransmitter(show_na=True): Generates and saves a bar chart showing the count of cells by neurotransmitter type.

    Usage:
    To use this class, initialize an instance with the desired modalities and keywords, and then call its methods to generate and save the visualizations:

    ```python
    figure_maker = make_figures_FK(modalities=['pa', 'clem'], keywords=['integrator'])
    figure_maker.plot_neurotransmitter()
    figure_maker.plot_z_projection(show_brs=True)
    """

    def __init__(self, modalities=['pa'],
                 keywords=['integrator', 'ipsilateral'],
                 use_smooth_pa=True,
                 mirror=True,
                 only_soma=False,
                 load_what='swc'):
        """
        Initializes the make_figures_FK class, setting up necessary parameters, loading datasets, and preparing data for visualization.

        This constructor sets up the data path based on a configuration file, loads cell data according to specified modalities, and filters this data based on given keywords. It also initializes various settings that affect the visualization such as whether to use smoothed photoactivation data, whether to mirror mesh data across a midline, and whether to visualize only the soma part of the cells.

        Parameters:
        - modalities (list of str): List of modalities from which to load cell data, such as 'pa' for photoactivation or 'clem' for correlative light and electron microscopy. Defaults to ['pa'].
        - keywords (list of str): List of keywords to filter cells by type, which could include terms like 'integrator', 'ipsilateral', or other specific labels found within the cell data. Defaults to ['integrator', 'ipsilateral'].
        - use_smooth_pa (bool): Whether to use smoothed representations for photoactivation data. Defaults to True.
        - mirror (bool): Whether to mirror cell mesh data across the specified midline to ensure correct orientation. Defaults to True.
        - only_soma (bool): Whether to limit the visualization to only the soma part of each cell, ignoring other components like dendrites or axons. Defaults to False.

        The function automatically handles the creation of directories needed for output based on specified parameters and ensures that all cell data is prepared and loaded for subsequent visualization tasks. Additionally, it saves a list of used cells based on the filtering criteria to facilitate reproducibility and further analysis.

        Example usage:
            instance = make_figures_FK(modalities=['pa', 'clem'], keywords=['integrator', 'contralateral'])
            This instance will be ready to plot cells based on photoactivation and CLEM modalities, specifically those labeled as 'integrator' or 'contralateral'.
        """

        # Record the current datetime to timestamp outputs for uniqueness and tracking.
        self.name_time = datetime.now()
        # Set the flag for applying smoothing to photoactivation data based on the constructor argument.
        self.use_smooth_pa = use_smooth_pa
        # Set the base path for data by reading from a configuration file; ensures correct data location is used.

        self.path_to_data = get_base_path()  # Ensure this path is set in path_configuration.txt

        # Define a dictionary mapping cell types to specific RGBA color codes for consistent visual representation.
        self.color_cell_type_dict = {
            "integrator_ipsi": (254, 179, 38, 0.7),
            "integrator_contra": (232, 77, 138, 0.7),
            "dynamic threshold": (100, 197, 235, 0.7),
            "motor command": (127, 88, 175, 0.7),
        }

        loaded_tables = []

        # Load the photoactivation table if 'pa' modality is selected; path assumes a specific directory structure.
        if 'pa' in modalities:
            pa_table = load_pa_table(self.path_to_data.joinpath("paGFP").joinpath("photoactivation_cells_table.csv"))
            loaded_tables.append(pa_table)

        # Load the CLEM table if 'clem' modality is selected; path also assumes a specific directory structure.
        if 'clem' in modalities:
            clem_table = load_clem_table(self.path_to_data.joinpath('clem_zfish1').joinpath('all_cells'))
            loaded_tables.append(clem_table)

        if 'em' in modalities:


                em_table1 = load_em_table(self.path_to_data.joinpath('em_zfish1').joinpath('data_cell_89189_postsynaptic_partners').joinpath('output_data'))
                em_table2 = load_em_table(self.path_to_data.joinpath('em_zfish1').joinpath('data_seed_cells').joinpath('output_data'))
                em_table3 = load_em_table(self.path_to_data.joinpath('em_zfish1').joinpath('cell_010_postsynaptic_partners').joinpath('output_data'))
                em_table4 = load_em_table(self.path_to_data.joinpath('em_zfish1').joinpath('cell_011_postsynaptic_partners').joinpath('output_data'))
                em_table5 = load_em_table(self.path_to_data.joinpath('em_zfish1').joinpath('cell_019_postsynaptic_partners').joinpath('output_data'))
                em_table = pd.concat([em_table1, em_table2, em_table3,em_table4,em_table5])
                em_table.columns = ['cell_name', 'bad_name', 'units', 'tracer_name', 'imaging_modality','soma_position', 'classifier', 'mece_regions', 'others','date_of_tracing', 'presynaptic', 'postsynaptic', 'metadata_path']
                loaded_tables.append(em_table)



        # Concatenate data from different modalities into a single DataFrame if multiple modalities are specified.
        if len(modalities) > 1:
            all_cells = pd.concat(loaded_tables)
        elif len(modalities) == 1:
            all_cells = loaded_tables[0]
        all_cells = all_cells.reset_index(drop=True)

        self.keywords = keywords
        # Filter the concatenated cell data based on specified keywords.

        def has_numbers(inputString):
            return any(char.isdigit() for char in inputString)

        keywords_subset_to_cell_names = [has_numbers(x) for x in keywords]
        keyword_cells = np.array(keywords)[keywords_subset_to_cell_names]

        if keyword_cells.size == 0:
            pass
        else:
            all_cells = all_cells.loc[all_cells['cell_name'].isin(keyword_cells),:]


        if keywords == 'all':
            pass
        else:
            for keyword in keywords:
                if not has_numbers(keyword):
                    subset_for_keyword = all_cells['cell_type_labels'].apply(lambda label: keyword.replace("_", " ") in label or keyword in label)
                    all_cells = all_cells[subset_for_keyword]

        # Set specific brain regions to be included in visualizations.
        self.selected_meshes = ["Retina", 'Midbrain', "Olfactory Bulb", "Forebrain", "Habenula", "Hindbrain","Hindbrain_line", "Spinal Cord", "raphe", 'eye1', 'eye2', 'cerebellar_neuropil', 'Rhombencephalon - Rhombomere 1',
                                'Rhombencephalon - Rhombomere 2', "cn1", "cn2", 'Mesencephalon - Tectum Stratum Periventriculare']

        # Initialize columns for different types of mesh data, setting default as NaN.
        for mesh_type in ["all_mesh",'soma_mesh', 'dendrite_mesh', 'axon_mesh', 'neurites_mesh','swc']:
            all_cells[mesh_type] = np.nan
            all_cells[mesh_type] = all_cells[mesh_type].astype(object)


        list_of_clem_tracers = ['Jay Hareshbhai Savaliya','Jonathan Boulanger-Weill']
        # If a cell was scored by Jonathan Boulanger-Weill, set its imaging modality to 'clem'.
        try:
            all_cells.loc[all_cells['tracer_names'].isin(list_of_clem_tracers), 'imaging_modality'] = 'clem'  # Confirm with Jonathan regarding the use of 'clem' as a label.
        except:
            pass
        # Load mesh data for each cell based on selected modalities and smoothing setting.
        for i, cell in all_cells.iterrows():
            if load_what=='mesh':
                all_cells.loc[i, :] = load_mesh(cell, self.path_to_data, use_smooth_pa=self.use_smooth_pa)
            if load_what == 'swc':
                all_cells.loc[i, :] = load_mesh(cell, self.path_to_data, use_smooth_pa=self.use_smooth_pa, swc=True)
            if load_what == 'both':
                all_cells.loc[i, :] = load_mesh(cell, self.path_to_data, use_smooth_pa=self.use_smooth_pa,load_both=True)

        # Load synapse data for each cell based on selected modalities and smoothing setting.
        for i, cell in all_cells.iterrows():
            if cell['imaging_modality'] == "clem":
                all_cells.loc[i, :] = load_synapse_clem(cell, self.path_to_data)
                print(f'Synapses loaded for cell {cell["cell_name"]}')

        # Mirror cell data if specified, adjusting for anatomical accuracy.
        width_brain = 495.56  # The width of the brain for mirror transformations.
        if mirror:
            for i, cell in all_cells.iterrows():
                if type(cell['soma_mesh']) != float and type(cell['soma_mesh']) != type(None):
                    if np.mean(cell['soma_mesh']._vertices[:, 0]) > (width_brain / 2):  # Determine if the cell is in the right hemisphere.
                        # Mirror various mesh data based on imaging modality.
                        all_cells.loc[i, 'soma_mesh']._vertices = navis.transforms.mirror(cell['soma_mesh']._vertices, width_brain, 'x')
                        if cell['imaging_modality'] == 'photoactivation':
                            all_cells.loc[i, 'neurites_mesh']._vertices = navis.transforms.mirror(cell['neurites_mesh']._vertices, width_brain, 'x')
                            all_cells.loc[i, 'all_mesh']._vertices = navis.transforms.mirror(cell['all_mesh']._vertices, width_brain, 'x')
                        if cell['imaging_modality'] == 'clem' or cell['imaging_modality'] == 'em':
                            all_cells.loc[i, 'axon_mesh']._vertices = navis.transforms.mirror(cell['axon_mesh']._vertices, width_brain, 'x')
                            all_cells.loc[i, 'dendrite_mesh']._vertices = navis.transforms.mirror(cell['dendrite_mesh']._vertices, width_brain, 'x')
                            all_cells.loc[i, 'all_mesh'].connectors.loc[:,["x",'y','z']] = navis.transforms.mirror(np.array(cell['all_mesh'].connectors.loc[:, ['x', 'y', 'z']]), width_brain, 'x')
                        print(f"MESHES of cell {cell['cell_name']} mirrored")

                if 'swc' in cell.index:
                    if type(cell['swc']) != float and type(cell['swc']) != type(None):
                        if cell['swc'].nodes.loc[0, 'x'] > (width_brain / 2) and all_cells.loc[i, 'swc'].connectors is not None:
                            all_cells.loc[i, 'swc'].nodes.loc[:, ["x", "y", "z"]] = navis.transforms.mirror(np.array(cell['swc'].nodes.loc[:, ['x', 'y', 'z']]), width_brain, 'x')
                            all_cells.loc[i, 'swc'].connectors.loc[:, ["x", 'y', 'z']] = navis.transforms.mirror(np.array(cell['swc'].connectors.loc[:, ['x', 'y', 'z']]), width_brain, 'x')
                            print(f"SWC of cell {cell['cell_name']} mirrored")

        # Finalize the all_cells attribute with the loaded and possibly transformed cell data.
        all_cells = all_cells.dropna(how='all')
        self.all_cells = all_cells


        # Create a directory for storing information on the used cells and save the list of cell names.
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("used_cells"), exist_ok=True)
        try:
            all_cells['cell_name'].to_csv(self.path_to_data.joinpath("make_figures_FK_output").joinpath("used_cells").joinpath(f'{"_".join(self.keywords)}_{self.name_time.strftime("%Y-%m-%d_%H-%M-%S")}.txt'), index=False,
                                          header=None)
        except:
            pass

    def plot_projection(self, projection='z', show_brs=False, force_new_cell_list=False, rasterize=True,
                        black_neuron=True, standard_size=True, volume_outlines=True, background_gray=True,
                        only_soma=False, midline=True,plot_synapse_distribution=True,which_brs='raphe'):
        """
        Generates and saves a 2D projection plot of visualized brain cells, optionally including selected brain regions and other visual enhancements.

        This method allows for the creation of either a Z-axis or Y-axis projection plot of the brain cells. It includes options to include brain regions, adjust the appearance of neurons, and apply various visual effects such as volume outlines and a midline indicator.

        Parameters:
        - projection (str): Specifies the axis for the projection. Can be 'z' or 'y' to indicate Z-axis or Y-axis projection, respectively. Defaults to 'z'.
        - show_brs (bool): Whether to include selected brain regions in the plot. Defaults to False.
        - force_new_cell_list (bool): Forces the generation of a new list of visualized cells if set to True. Useful if updates to cell data are made after initialization. Defaults to False.
        - rasterize (bool): Whether to rasterize components of the plot to improve rendering performance. Defaults to True.
        - black_neuron (bool or str): Can be set to True to color all neurons black or can be a string specifying the name of a specific neuron to color black. Defaults to True.
        - standard_size (bool): If True, standardizes the size of the plot for consistent presentation. Defaults to True.
        - volume_outlines (bool): Whether to draw outlines around brain volume components in the plot. Defaults to True.
        - background_gray (bool): If True, fills the background of brain regions with a light gray color to make neurons stand out. Defaults to True.
        - only_soma (bool): If True, only the soma part of neurons is visualized. Defaults to False.
        - midline (bool): Whether to include a midline indicator on the plot. Defaults to True.

        The method loads brain region meshes if `show_brs` is True, applies specified visual settings, and generates the plot. The resulting plot is saved in PDF, PNG, and SVG formats in specifically named directories that reflect the projection type and settings used.

        Example usage:
            instance.plot_projection(projection='y', show_brs=True, black_neuron='specific_neuron_name')
            This will generate a Y-axis projection including brain regions, with the specific neuron colored black.

        Note:
        - The function assumes that all necessary data and mesh files are pre-loaded and available through the class's attributes. If `force_new_cell_list` is True, it will re-generate the list of visualized cells based on current class data.
        """

        # Determine the view settings based on the projection type ('z' or 'y').
        if projection == "z":
            view = ('x', "-y")  # Set the 2D view to the X-Y plane for Z projection.
            ylim = [-850, -50]  # Define the Y-axis limits for the Z projection.
        elif projection == 'y':
            view = ('x', "z")  # Set the 2D view to the X-Z plane for Y projection.
            ylim = [-30, 300]  # Define the Y-axis limits for the Y projection.
        projection_string = projection +"_"+ which_brs + "_projection"  # Create a string to denote the type

        # Rebuild the list of visualized cells and their colors if necessary.
        if not "visualized_cells" in self.__dir__() or force_new_cell_list:
            self.visualized_cells = []  # Reset the list of cells to be visualized.
            self.color_cells = []  # Reset the list of colors corresponding to the cells.

            # Iterate over all cells to determine their colors based on their types and specific conditions.
            for i, cell in self.all_cells.iterrows():
                if black_neuron == True and cell["imaging_modality"] == "photoactivation":
                    # Color all photoactivation modality cells black if specified.
                    self.color_cells.append("black")
                    self.color_cells.append("black")
                    black_neuron = False
                elif type(black_neuron) == str:
                    # Color a specific neuron black if its name matches the specified string.
                    if cell['cell_name'] == black_neuron:
                        self.color_cells.append("black")
                        self.color_cells.append("black")
                else:
                    # Assign colors based on cell type labels using a predefined color dictionary.
                    if 'cell_type_labels' in cell.index and type(cell.cell_type_labels)!= float:
                        for label in cell.cell_type_labels:
                            if label == "integrator" and "ipsilateral" in cell.cell_type_labels:
                                temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_ipsi"]
                                break
                            elif label == "integrator" and "contralateral" in cell.cell_type_labels:
                                temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_contra"]
                                break
                            elif label.replace("_", " ") in self.color_cell_type_dict.keys():
                                temp_color = self.color_cell_type_dict[label.replace("_", " ")]
                                break
                            else:
                                temp_color = 'k'
                    else:
                        temp_color = 'k'

                    # Append visualized cells and their colors.
                    for key in ["soma_mesh", "axon_mesh", "dendrite_mesh", "neurites_mesh"]:
                        if only_soma:
                            if not type(cell[key]) == float and key == "soma_mesh":
                                self.visualized_cells.append(navis.MeshNeuron(navis.Volume(cell[key]).resize(2)))
                                self.visualized_cells[-1].units = 'micrometer'
                                self.color_cells.append(temp_color)
                        else:
                            if not type(cell[key]) == float:
                                if not type(cell[key]) == float:
                                    self.visualized_cells.append(cell[key])
                                    if key != "dendrite_mesh":
                                        self.color_cells.append(temp_color)
                                    elif key == "dendrite_mesh":
                                        self.color_cells.append("black")
        if self.visualized_cells == []:
            self.visualized_cells = []  # Reset the list of cells to be visualized.
            self.color_cells = []  # Reset the list of colors corresponding to the cells.

            # Iterate over all cells to determine their colors based on their types and specific conditions.
            for i, cell in self.all_cells.iterrows():
                if not type(cell['swc']) == float:
                    if black_neuron == True and cell["imaging_modality"] == "photoactivation":
                        # Color all photoactivation modality cells black if specified.
                        self.color_cells.append("black")
                        self.color_cells.append("black")
                        black_neuron = False
                    elif type(black_neuron) == str:
                        # Color a specific neuron black if its name matches the specified string.
                        if cell['cell_name'] == black_neuron:
                            self.color_cells.append("black")
                            self.color_cells.append("black")
                    else:
                        # Assign colors based on cell type labels using a predefined color dictionary.
                        if 'cell_type_labels' in cell.index and type(cell.cell_type_labels)!= float:
                            for label in cell.cell_type_labels:
                                if label == "integrator" and "ipsilateral" in cell.cell_type_labels:
                                    temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_ipsi"]
                                    break
                                elif label == "integrator" and "contralateral" in cell.cell_type_labels:
                                    temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_contra"]
                                    break
                                elif label.replace("_", " ") in self.color_cell_type_dict.keys():
                                    temp_color = self.color_cell_type_dict[label.replace("_", " ")]
                                    break
                                else:
                                    temp_color = 'k'
                        else:
                            temp_color = 'k'





                    self.visualized_cells.append(cell['swc'])
                    self.visualized_cells[-1].units = 'micrometer'
                    self.color_cells.append(temp_color)






        # Load brain regions and initialize settings for plot if selected brain regions should be shown.
        if show_brs:
            brkw = "_with_brs_"
            brain_meshes = load_brs(self.path_to_data, which_brs=which_brs)
            brain_meshes_with_vertices = load_brs(self.path_to_data, which_brs=which_brs, as_volume=False)
            selected_meshes = self.selected_meshes
            brain_meshes = [mesh for mesh in brain_meshes if mesh.name in selected_meshes]
            brain_meshes_with_vertices = [mesh for mesh in brain_meshes_with_vertices if mesh.name in selected_meshes]
            color_meshes = [(0.4, 0.4, 0.4, 0.1)] * len(brain_meshes)
            for i, mesh in enumerate(brain_meshes):
                brain_meshes[i]._vertices = brain_meshes_with_vertices[i]._vertices
                brain_meshes[i]._faces = brain_meshes_with_vertices[i]._faces
        else:
            brkw = "_without_brs_"

        #gridspec
        #
        #
        #
        #
        #
        #

        fig = plt.figure(figsize=(8, 8))
        gs = plt.GridSpec(2, 2, width_ratios=[4, 1], height_ratios=[1, 4])
        ax = plt.subplot(gs[1, 0])
        ax_top = plt.subplot(gs[0, 0], sharex=ax)
        ax_legend = plt.subplot(gs[0, 1])
        ax_right = plt.subplot(gs[1, 1], sharey=ax)
        ax_top.axis('off')
        ax_right.axis('off')

        # Begin plotting the projection using navis plot2d, applying color settings and other parameters.
        if show_brs:
            navis.plot2d(brain_meshes, color=color_meshes, volume_outlines=volume_outlines,
                         alpha=0.2, linewidth=0.5, method='2d', view=view, group_neurons=True,
                         rasterize=False, ax=ax)
            if background_gray:
                # Optionally fill the background of brain regions with gray for better visibility.
                for mesh in brain_meshes:
                    temp_convex_hull = np.array(mesh.to_2d(view=view))
                    ax.fill(temp_convex_hull[:, 0], temp_convex_hull[:, 1], c='#F7F7F7', zorder=-1, alpha=1, ec=None)
            navis.plot2d(self.visualized_cells, color=self.color_cells, alpha=1, linewidth=0.5,
                         method='2d', view=view, group_neurons=True, rasterize=rasterize, ax=ax,
                         scalebar="20 um")
        else:
            navis.plot2d(self.visualized_cells, color=self.color_cells, alpha=1, linewidth=0.5,
                         method='2d', view=view, group_neurons=True, rasterize=rasterize,
                         scalebar="20 um", ax=ax)

        ax.set_aspect('equal')
        # Include a midline indicator if specified.
        if midline:
            ax.axvline(250, color=(0.85, 0.85, 0.85, 0.2), linestyle='--', alpha=0.5, zorder=0)
        if standard_size:
            plt.xlim(0, 500)  # Standardize the plot dimensions.
            plt.ylim(ylim[0], ylim[1])  # Set specific limits for the Y-axis based on the projection.
            ax.set_facecolor('white')  # Set the background color of the plot to white for clarity.
        # plot synapse_distribution
        if plot_synapse_distribution and (np.unique(self.all_cells['imaging_modality']) == ['clem']).all():
            ax4synapses = [x.replace('-', "") for x in list(view)]
            try:
                self.all_synapses = pd.concat([x.connectors for x in self.all_cells.loc[:, 'swc']])
            except:
                self.all_synapses = pd.concat([x.connectors for x in self.all_cells.loc[:, 'all_mesh']])
            # extract synapses for plotted axis
            post_ax0 = self.all_synapses.loc[self.all_synapses['type'] == 'post', ax4synapses[0]].to_list()
            pre_ax0 = self.all_synapses.loc[self.all_synapses['type'] == 'pre', ax4synapses[0]].to_list()
            post_ax1 = self.all_synapses.loc[self.all_synapses['type'] == 'post', ax4synapses[1]].to_list()
            pre_ax1 = self.all_synapses.loc[self.all_synapses['type'] == 'pre', ax4synapses[1]].to_list()
            if np.max(ylim) < 0:
                post_ax1 = [-x for x in post_ax1]
                pre_ax1 = [-x for x in pre_ax1]
            # kde estimation
            kde_post_ax0 = gaussian_kde(post_ax0)
            kde_pre_ax0 = gaussian_kde(pre_ax0)
            kde_post_ax1 = gaussian_kde(post_ax1)
            kde_pre_ax1 = gaussian_kde(pre_ax1)
            # evaluate kde
            ax0_values = np.linspace(min(plt.xlim()), max(plt.xlim()), 1000)
            ax1_values = np.linspace(min(plt.ylim()), max(plt.ylim()), 1000)
            kde_values_post_ax0 = kde_post_ax0(ax0_values)
            kde_values_pre_ax0 = kde_pre_ax0(ax0_values)
            kde_values_post_ax1 = kde_post_ax1(ax1_values)
            kde_values_pre_ax1 = kde_pre_ax1(ax1_values)

            gs.update(left=0.05, right=0.95, top=0.95, bottom=0.05, wspace=0.001, hspace=0.001)
            pos_main = ax.get_position().bounds
            # ax_top.axis('auto')
            # ax_right.axis('auto')
            ax_top.set_position((pos_main[0], pos_main[1] + pos_main[3] + 0.01, pos_main[2], pos_main[3] * 0.15))
            # ax_right.set_position((pos_main[0] + pos_main[2] + 0.01, pos_main[1], pos_main[3] * 0.15, pos_main[3]))
            ax_top.plot(ax0_values, kde_values_post_ax0, color='blue', alpha=0.5,label='pre-synapse')
            ax_top.plot(ax0_values, kde_values_pre_ax0, color='orange', alpha=0.5,label='post-synapse')
            ax_right.plot(kde_values_post_ax1, ax1_values, color='blue', alpha=0.5)
            ax_right.plot(kde_values_pre_ax1, ax1_values, color='orange', alpha=0.5)
            ax_top.fill_between(ax0_values, kde_values_post_ax0, color='blue', alpha=0.1)
            ax_top.fill_between(ax0_values, kde_values_pre_ax0, color='orange', alpha=0.1)
            ax_right.fill_betweenx(ax1_values, kde_values_post_ax1, color='blue', alpha=0.1)
            ax_right.fill_betweenx(ax1_values, kde_values_pre_ax1, color='orange', alpha=0.1)
            ax_top.tick_params(
                axis='x',  # changes apply to the x-axis
                which='both',  # both major and minor ticks are affected
                bottom=False,  # ticks along the bottom edge are off
                top=False,  # ticks along the top edge are off
                labelbottom=False)
            ax_right.tick_params(
                axis='y',  # changes apply to the x-axis
                which='both',  # both major and minor ticks are affected
                left=False,
                labelleft=False,  # ticks along the bottom edge are off
                top=False,  # ticks along the top edge are off
                labelbottom=False)
            ax.axis('off')
            ax_top.spines['top'].set_visible(False)
            ax_top.spines['right'].set_visible(False)
            ax_top.spines['bottom'].set_visible(False)
            ax_right.spines['top'].set_visible(False)
            ax_right.spines['right'].set_visible(False)
            ax_right.spines['left'].set_visible(False)

            max_value = (np.ceil(np.max([kde_values_post_ax0, kde_values_pre_ax0, kde_values_post_ax1, kde_values_pre_ax1]) * 1000)) / 1000
            ax_right.set_xlim(0, max_value)
            ax_top.set_ylim(0, max_value)
            ax_top.set_yticks([0, round(max_value / 2, 2), round(max_value, 2)], [0, round(max_value / 2, 2), round(max_value, 2)])
            ax_right.set_xticks([0, round(max_value / 2, 2), round(max_value, 2)], [0, round(max_value / 2, 2), round(max_value, 2)])
            ax_top.set_anchor('C')
            pos_main = ax.get_position().bounds
            ax_top.set_position((pos_main[0], pos_main[1] + pos_main[3] + 0.01, pos_main[2], pos_main[3] * 0.15))
            ax_right.set_position((pos_main[0] + pos_main[2] + 0.01, pos_main[1], pos_main[3] * 0.15, pos_main[3]))


            legend_elements = [Line2D([0], [0], color='blue', lw=4, label='Post-synapse'),
                               Line2D([0], [0], color='orange',lw=4, label='Pre-synapse')]
            ax_legend.legend(handles=legend_elements, loc='center',frameon=False)
            ax_legend.axis('off')


        ax.axis('off')


        # Create directories for saving the output files if they do not already exist.
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("pdf"), exist_ok=True)
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("png"), exist_ok=True)
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("svg"), exist_ok=True)

        # Save the figure in different formats at the specified resolution.
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("pdf").joinpath(
            rf"{projection_string[:30]}{brkw}{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.pdf"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("png").joinpath(
            rf"{projection_string[:30]}{brkw}{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.png"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath(projection_string[:30]).joinpath("svg").joinpath(
            rf"{projection_string[:30]}{brkw}{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.svg"), dpi=1200)
        print(f"{projection_string[:30]} saved!")  # Notify the user that the plot has been saved successfully.

    def plot_y_projection(self, **kwargs):
        """
        Convenience method to generate and save a Y-axis projection plot of visualized brain cells using predefined settings.

        This method serves as a wrapper for the `plot_projection` function, specifically setting the projection to the Y-axis. It forwards any additional keyword arguments to customize the plot according to the userâ€™s requirements, such as including brain regions, applying visual enhancements, or modifying neuron appearance.

        Parameters:
        - **kwargs: Variable keyword arguments that are passed directly to the `plot_projection` method to customize the plot. Common parameters include `show_brs` for displaying brain regions, `force_new_cell_list` for refreshing the data, and visual settings like `rasterize`, `black_neuron`, and `background_gray`.

        This method simplifies the process of creating a Y-axis projection by encapsulating the projection parameter, making the function call more intuitive for specific visualization needs.

        Example usage:
            instance.plot_y_projection(show_brs=True, black_neuron=False)
            This will generate a Y-axis projection plot including brain regions, without coloring neurons black.

        Note:
        - For a detailed explanation of all customizable parameters, refer to the docstring of the `plot_projection` method.
        """
        self.plot_projection(projection='y', **kwargs)  # Directly calls the plot_projection method with 'y' axis setting


    def plot_z_projection(self, **kwargs):
        """
        Convenience method to generate and save a Z-axis projection plot of visualized brain cells using predefined settings.

        This method serves as a wrapper for the `plot_projection` function, setting the projection specifically to the Z-axis. It accepts any additional keyword arguments to tailor the plot, such as including brain regions, adjusting visual settings, or specifying which parts of the neurons to visualize.

        Parameters:
        - **kwargs: Variable keyword arguments that are passed directly to the `plot_projection` method to customize the plot. Common parameters might include `show_brs` to display brain regions, `force_new_cell_list` to refresh the data before plotting, and other visual enhancements like `rasterize`, `black_neuron`, and `volume_outlines`.

        This method simplifies the process of creating a Z-axis projection by encapsulating the projection parameter. It provides a more straightforward interface for generating specific visualizations tailored to user needs.

        Example usage:
            instance.plot_z_projection(show_brs=True, only_soma=True)
            This will generate a Z-axis projection plot including brain regions, displaying only the somas of the neurons.

        Note:
        - For detailed descriptions of all customizable parameters, refer to the docstring of the `plot_projection` method.
        """
        self.plot_projection(projection='z', **kwargs)  # Directly calls the plot_projection method with 'x' axis setting





    def make_interactive(self, show_brs=True,force_new_cell_list=False,which_brs='whole_brain'):
        """
        Generates and saves an interactive 3D plot of visualized brain cells, optionally including selected brain regions.

        This function leverages the Plotly library to create a dynamic, interactive 3D visualization of brain cells. Users can
        choose to include a predefined set of brain regions in the visualization, enhancing the contextual understanding of the
        spatial arrangement of cells. The plot settings such as orientation and scaling of axes are optimized for clarity and
        ease of interaction.

        Parameters:
        - show_brs (bool): Determines whether to include brain regions in the visualization. If True, brain regions are
                           loaded and visualized alongside the brain cells. If False, only the brain cells are visualized.
                           Defaults to True.
        - force_new_cell_list (bool): If True, forces the regeneration of the list of cells to be visualized based on the
                                      current configuration. This is useful if updates to cell data or visualization preferences
                                      have occurred since the last plot generation. Defaults to False.

        The generated 3D plot is saved as an HTML file in a predefined directory structure, which includes a timestamp in the
        filename to ensure that each visualization is uniquely identifiable and does not overwrite previous files.

        Example usage:
            instance.make_interactive(show_brs=True)
            This call will generate a 3D plot including brain regions, enhancing the visualization with additional anatomical context.

        Note:
        - The function ensures all necessary directories exist before saving the plot, using standard file management routines
          to organize output effectively.
        - The interactive plot is saved but not automatically opened, allowing users to open it manually at their convenience.
        """
        # Initialize a flag to manage conditional coloring of neurons, default is no special coloring.
        black_neuron = False

        if not "visualized_cells" in self.__dir__() or force_new_cell_list:
            self.visualized_cells = []
            self.color_cells = []

            for i, cell in self.all_cells.iterrows():
                if black_neuron == True and cell["imaging_modality"] == "photoactivation":
                    self.color_cells.append("black")
                    self.color_cells.append("black")
                    black_neuron = False
                elif type(black_neuron) == str:
                    if cell['cell_name'] == black_neuron:
                        self.color_cells.append("black")
                        self.color_cells.append("black")
                else:
                    for label in cell.cell_type_labels:
                        if label == "integrator" and "ipsilateral" in cell.cell_type_labels:
                            temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_ipsi"]

                        elif label == "integrator" and "contralateral" in cell.cell_type_labels:
                            temp_color = self.color_cell_type_dict[label.replace("_", " ") + "_contra"]
                        elif label.replace("_", " ") in self.color_cell_type_dict.keys():
                            temp_color = self.color_cell_type_dict[label.replace("_", " ")]
                            break
                    for key in ["soma_mesh", "axon_mesh", "dendrite_mesh", "neurites_mesh"]:
                        if not type(cell[key]) == float:
                            self.visualized_cells.append(cell[key])
                            if key != "dendrite_mesh":
                                self.color_cells.append(temp_color)
                            elif key == "dendrite_mesh":
                                self.color_cells.append("black")


        if show_brs:
            brkw = "_with_brs_"
        else:
            brkw = "_without_brs_"
        if show_brs:
            brain_meshes = load_brs(self.path_to_data, which_brs=which_brs)
            selected_meshes = self.selected_meshes
            brain_meshes = [mesh for mesh in brain_meshes if mesh.name in selected_meshes]
            color_meshes = [(0.4, 0.4, 0.4, 0.1)] * len(brain_meshes)

            fig = navis.plot3d(self.visualized_cells + brain_meshes, backend='plotly',
                               color=self.color_cells + color_meshes, width=1920, height=1080)
            fig.update_layout(
                scene={
                    'xaxis': {'autorange': 'reversed'},  # reverse !!!
                    'yaxis': {'autorange': True},

                    'zaxis': {'autorange': True},
                    'aspectmode': "data",
                    'aspectratio': {"x": 1, "y": 1, "z": 1}
                }
            )

            os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("html"), exist_ok=True)

            plotly.offline.plot(fig, filename=str(Path(self.path_to_data.joinpath("make_figures_FK_output").joinpath("html").joinpath(f"interactive{brkw[-1]}{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.html"))),auto_open=False, auto_play=False)
            print("Interactive saved!")

        else:
            fig = navis.plot3d(self.visualized_cells, backend='plotly',
                               color=self.color_cells, width=1920, height=1080)
            fig.update_layout(
                scene={
                    'xaxis': {'autorange': 'reversed'},  # reverse !!!
                    'yaxis': {'autorange': True},

                    'zaxis': {'autorange': True},
                    'aspectmode': "data",
                    'aspectratio': {"x": 1, "y": 1, "z": 1}
                }
            )
            os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("html"), exist_ok=True)


            plotly.offline.plot(fig, filename=str(Path(self.path_to_data.joinpath("make_figures_FK_output").joinpath("html").joinpath(f"interactive{brkw[-1]}{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.html"))),auto_open=False, auto_play=False)
            print("Interactive saved!")

    def plot_neurotransmitter(self, show_na=True):
        """
        Generates and saves a bar chart representing the distribution of cells classified by neurotransmitter type: inhibitory,
        excitatory, or unspecified (NA).

        This method counts the number of cells labeled as 'inhibitory', 'excitatory', or not specified (NA) within the dataset
        and visualizes these counts in a bar chart. The bars are distinctly colored to differentiate between the categories,
        enhancing the visual distinction between cell types. Users can opt to include or exclude the NA category in the visualization
        through the `show_na` parameter.

        Parameters:
        - show_na (bool): Determines whether to include the 'Not Applicable' (NA) category in the bar chart. If set to True,
                          the NA category is included, which represents cells that are not specified as either inhibitory or excitatory.
                          Defaults to True.

        The function saves the chart in multiple formats (PDF, PNG, SVG) within designated subdirectories to ensure accessibility and
        usability across different platforms and uses. The saved files include a timestamp and keyword designations to avoid
        overwriting previous plots and to facilitate easy identification.

        Example usage:
            instance.plot_neurotransmitter(show_na=False)
            This will generate and save a bar chart that excludes the unspecified neurotransmitter category, focusing only on
            inhibitory and excitatory cells.

        Note:
        - This function relies on matplotlib for generating the bar chart. Ensure that this library is installed and properly configured
          in your environment.
        - The directory structure for saving the outputs is automatically managed by the method, which checks for existing paths
          and creates them if necessary.
        """

        inhibitory_count = 0
        excitatory_count =0
        na_count = 0

        for i,cell in self.all_cells.iterrows():
            if "inhibitory" in cell.cell_type_labels:
                inhibitory_count += 1
            elif "excitatory" in cell.cell_type_labels:
                excitatory_count += 1
            else:
                na_count += 1
        # fig = plt.figure()
        # plt.bar([1], [inhibitory_count], color="orange",width =0.9)
        # plt.bar([2], [excitatory_count], color="blue",width =0.9)
        # plt.bar([3], [na_count], color="gray",width =0.9)
        # plt.xticks([1, 2, 3], ["I", "E", "NA"])
        # ax = plt.gca()
        # ax.yaxis.set_major_locator(MaxNLocator(integer=True))


        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("pdf"),exist_ok=True)
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("png"),exist_ok=True)
        os.makedirs(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("svg"),exist_ok=True)

        #stacked bar plot

        cmap = cm.get_cmap('Greys')
        g1,g2,g3 = cmap(0.8),cmap(0.6),cmap(0.4)

        width =1
        colors = [g1,g2,g3]
        all_nt = [inhibitory_count,excitatory_count,na_count]
        texts = ['Gad1b+',"Vglut2a+", "Unclear"]
        fig, ax = plt.subplots()
        current_position = 0
        for nt_count,color,text in zip(all_nt, colors,texts):
            if nt_count!=0:
                ax.bar(0,nt_count,bottom = current_position, width=width,color = color)
                ax.text(1, current_position+(nt_count/2),text,ha='left',va='center',c='k')
                ax.text(0, current_position + (nt_count / 2), nt_count,ha='center',va='center',c='white')
                current_position += nt_count + (np.sum(all_nt)*0.01)

        ax.axis('equal')
        ax.set_xticks([])
        ax.set_yticks([])
        ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)


        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("pdf").joinpath(rf"neurotransmitter_stacked_bar_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.pdf"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("png").joinpath(rf"neurotransmitter_stacked_bar_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.png"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("svg").joinpath(rf"neurotransmitter_stacked_bar_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.svg"), dpi=1200)


        #simple bar
        width = 1
        locs = [1.5 * (x * width) for x in range(3)]
        fig, ax = plt.subplots()
        for nt_count,color,text,loc in zip(all_nt, colors,texts,locs):
            ax.bar(loc,nt_count, width=width,color = g3)

            ax.text(loc, (nt_count / 2), nt_count,ha='center',va='center',c='white')
        ax.set_xticks(locs,texts,rotation=45)
        ax.set_yticks([])


        ax.axis('equal')
        ax.spines[['right', 'top','left','bottom']].set_visible(False)
        fig.subplots_adjust(bottom=0.15)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("pdf").joinpath(rf"neurotransmitter_simple_gray_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.pdf"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("png").joinpath(rf"neurotransmitter_simple_gray_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.png"), dpi=1200)
        fig.savefig(self.path_to_data.joinpath("make_figures_FK_output").joinpath("neurotransmitter").joinpath("svg").joinpath(rf"neurotransmitter_simple_gray_{'_'.join(self.keywords)}_{self.name_time.strftime('%Y-%m-%d_%H-%M-%S')}.svg"), dpi=1200)






        print("Neurotransmitter saved!")
        
        

if __name__ == "__main__":
    kk = make_figures_FK(modalities=['pa'],
                         keywords=['dynamic_threshold'],
                                                   use_smooth_pa=True,
                                                   mirror=True,
                                                   only_soma=True,
                                                   load_what='mesh')

        kk.plot_y_projection(show_brs=True,
                                                   which_brs="raphe",
                                                   force_new_cell_list=False,
                                                   rasterize=True,
                                                   black_neuron=False,
                                                   standard_size=True,
                                                   volume_outlines=True,
                                                   background_gray=True,
                                                   only_soma=False,
                                                   midline=True,
                                                   plot_synapse_distribution=False)

        kk.plot_z_projection(show_brs=True,
                             which_brs="raphe",
                             force_new_cell_list=False,
                             rasterize=True,
                             black_neuron=False,
                             standard_size=True,
                             volume_outlines=True,
                             background_gray=True,
                             only_soma=False,
                             midline=True,
                             plot_synapse_distribution=False)

